<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lexical Analysis - Python</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <a href="#Lexical_analysis_in_Python"><button id="top">Top</button></a>
    <nav id="navbar">
        <header id="Lexical_analysis_in_Python">Lexical analysis in Python</header>
        <div class="source-box"><a id="a-source"href="https://docs.python.org/3/reference/lexical_analysis.html" target="_blank">Content Source</a></div>
        <a href="#Introduction" class="nav-link">Introduction</a>
        <a href="#Line_structure" class="nav-link">Line structure</a>
        <a href="#Logical_lines" class="nav-link">Logical lines</a>
        <a href="#Physical_lines" class="nav-link">Physical lines</a>
        <a href="#Comments" class="nav-link">Comments</a>
        <a href="#Encoding_declarations" class="nav-link">Encoding declarations</a>
        <a href="#Explicit_line_joining" class="nav-link">Explicit line joining</a>
        <a href="#List" class="nav-link">List</a>

    </nav>
    <main id="main-doc">
        <section class="main-section" id="Introduction">
            <header>Introduction</header>
            <p>A Python program is read by a parser. Input to the parser is a stream of tokens, generated by the lexical
                analyzer. This chapter describes how the lexical analyzer breaks a file into tokens.</p>
            <p>Python reads program text as Unicode code points; the encoding of a source file can be given by an
                encoding declaration and defaults to UTF-8, see PEP 3120 for details. If the source file cannot be
                decoded, a SyntaxError is raised.</p>
        </section>
        <section class="main-section" id="Line_structure">
            <header>Line structure</header>
            <p>A Python program is divided into a number of logical lines.</p>
        </section>
        <section class="main-section" id="Logical_lines">
            <header>Logical Lines</header>
            <p>The end of a logical line is represented by the token NEWLINE. Statements cannot cross logical line
                boundaries except where NEWLINE is allowed by the syntax (e.g., between statements in compound
                statements). A logical line is constructed from one or more physical lines by following the explicit or
                implicit line joining rules.</p>
        </section>
        <section class="main-section" id="Physical_lines">
            <header>Physical lines</header>
            <p>A physical line is a sequence of characters terminated by an end-of-line sequence. In source files and
                strings, any of the standard platform line termination sequences can be used - the Unix form using ASCII
                LF (linefeed), the Windows form using the ASCII sequence CR LF (return followed by linefeed), or the old
                Macintosh form using the ASCII CR (return) character. All of these forms can be used equally, regardless
                of platform. The end of input also serves as an implicit terminator for the final physical line.</p>
            <p>When embedding Python, source code strings should be passed to Python APIs using the standard C
                conventions for newline characters (the <code>\n</code> character, representing ASCII LF, is the line
                terminator).</p>
        </section>
        <section class="main-section" id="Comments">
            <header>Comments</header>
            <p>A comment starts with a hash character (<code>#</code>) that is not part of a string literal, and ends at
                the end of the physical line. A comment signifies the end of the logical line unless the implicit line
                joining rules are invoked. Comments are ignored by the syntax.</p>
        </section>
        <section class="main-section" id="Encoding_declarations">
            <header>Encoding declarations</header>
            <p>If a comment in the first or second line of the Python script matches the regular expression coding
                <code>[=:]\s*([-\w.]+)</code>, this comment is processed as an encoding declaration; the first group of
                this expression names the encoding of the source code file. The encoding declaration must appear on a
                line of its own. If it is the second line, the first line must also be a comment-only line. The
                recommended forms of an encoding expression are
            </p>
            <code>
                # -*- coding: <encoding-name> -*-
            </code>
            <p>which is recognized also by GNU Emacs, and</p>
            <code>
                # vim:fileencoding=<encoding-name></encoding-name>
            </code>
            <p>which is recognized by Bram Moolenaar’s VIM.</p>
            <p>If no encoding declaration is found, the default encoding is UTF-8. In addition, if the first bytes of
                the file are the UTF-8 byte-order mark <code>(b'\xef\xbb\xbf')</code>, the declared file encoding is
                UTF-8 (this is supported, among others, by Microsoft’s notepad).</p>
            <p>If an encoding is declared, the encoding name must be recognized by Python. The encoding is used for all
                lexical analysis, including string literals, comments and identifiers.</p>
        </section>
        <section class="main-section" id="Explicit_line_joining">
            <header>Explicit line joining</header>
            <p>Two or more physical lines may be joined into logical lines using backslash characters (<code>\</code>),
                as follows: when a physical line ends in a backslash that is not part of a string literal or comment, it
                is joined with the following forming a single logical line, deleting the backslash and the following
                end-of-line character. For example:</p>
            <div class="code-box">
                <pre><code>if 1900 < year < 2100 and 1 <= month <= 12 \
and 1 <= day <= 31 and 0 <= hour < 24 \
and 0 <= minute < 60 and 0 <= second < 60:
                           # Looks like a valid date
        return 1</code></pre>
            </div>
        </section>
        <section class="main-section" id="List">
            <header>List</header>
            <p>The Unicode category codes mentioned above stand for:</p>
            <ul>
                <li>Lu - uppercase letters</li>
                <li>Ll - lowercase letters</li>
                <li>Lt - titlecase letters</li>
                <li>Lm - modifier letters</li>
                <li>Lo - other letters</li>
                <li>Nl - letter numbers</li>
                <li>Mn - nonspacing marks</li>
                <li>Mc - spacing combining marks</li>
                <li>Nd - decimal numbers</li>
                <li>Pc - connector punctuations</li>
                <li>Other_ID_Start - explicit list of characters in PropList.txt to support backwards
                    compatibility</li>
                <li>Other_ID_Continue - likewise</li>
            </ul>
        </section>
    </main>
    <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
</body>

</html>